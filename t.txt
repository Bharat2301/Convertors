i have backened folder in that i have converted folder after that i have uploads folder then i have .dockerignore file  node_modules
npm-debug.log
then i have .env file 
PORT=5001
FRONTEND_URL=http://localhost:5173
CONVERSION_TIMEOUT=120000
LIBREOFFICE_PATH=/usr/bin/unoconv
then i have Dockerfile file 
FROM node:18-bullseye

# Install system dependencies with clean up
RUN apt-get update && apt-get install -y \
    ffmpeg \
    libreoffice \
    libreoffice-writer \
    libreoffice-impress \
    libreoffice-calc \
    libreoffice-java-common \
    default-jre \
    ghostscript \
    calibre \
    unoconv \
    p7zip-full \
    pdftohtml \
    poppler-utils \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Create a user for LibreOffice to avoid permission issues
RUN useradd -m -u 1000 -G sudo officeuser \
    && mkdir -p /home/officeuser/.config/libreoffice/4/user \
    && chown -R officeuser:officeuser /home/officeuser

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .

# Set environment variables
ENV PORT=5001
ENV LIBREOFFICE_PATH=/usr/bin/unoconv
ENV FRONTEND_URL=https://convertors-frontend.onrender.com
ENV NODE_ENV=production
ENV HOME=/home/officeuser
ENV USER=officeuser

# Create necessary directories with correct permissions
RUN mkdir -p /app/Uploads /app/converted \
    && chown -R officeuser:officeuser /app

USER officeuser

# Start LibreOffice in headless mode before starting the server
CMD libreoffice --headless --accept="socket,host=127.0.0.1,port=2002;urp;" --norestore --nologo --nodefault & \
    sleep 10 && node server.js

EXPOSE $PORT
then i have package.json file 
{
  "name": "file-converter-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^17.2.0",
    "express": "^4.21.0",
    "fluent-ffmpeg": "^2.1.3",
    "libreoffice-convert": "^1.1.5",
    "multer": "^2.0.1",
    "node-7z": "^3.0.0",
    "path-to-regexp": "^8.2.0",
    "pdf2pic": "^3.2.0",
    "pdfkit": "^0.15.0",
    "sharp": "^0.34.3",
    "svgo": "^4.0.0",
    "tmp": "^0.2.3"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  },
  "description": ""
}
then i have server.js file 
if (process.env.NODE_ENV !== 'production') {
  require('dotenv').config({ debug: true });
}
const express = require('express');
const multer = require('multer');
const ffmpeg = require('fluent-ffmpeg');
const sharp = require('sharp');
const fs = require('fs');
const fsPromises = fs.promises;
const path = require('path');
const cors = require('cors');
const { optimize } = require('svgo');
const sevenZip = require('node-7z');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const tmp = require('tmp');
const { fromPath } = require('pdf2pic');
const PDFDocument = require('pdfkit');
const libre = require('libreoffice-convert'); // New dependency

// Log FFmpeg availability
try {
  ffmpeg.getAvailableFormats((err, formats) => {
    if (err) {
      console.error('FFmpeg not found or misconfigured:', err.message);
    } else {
      console.log('FFmpeg available. Supported formats:', Object.keys(formats).slice(0, 10), '...');
    }
  });
} catch (err) {
  console.error('Error checking FFmpeg:', err.message);
}

const app = express();
const port = process.env.PORT || 5001;

// Log environment variables
console.log('Environment variables:', {
  PORT: process.env.PORT,
  FRONTEND_URL: process.env.FRONTEND_URL,
  CONVERSION_TIMEOUT: process.env.CONVERSION_TIMEOUT,
  LIBREOFFICE_PATH: process.env.LIBREOFFICE_PATH,
});

// Enhanced CORS configuration
app.use(cors({
  origin: (origin, callback) => {
    const allowedOrigins = [
      'http://localhost:5173',
      process.env.FRONTEND_URL || 'https://convertors-frontend.onrender.com'
    ].filter(Boolean);
    console.log(`CORS: Request from origin ${origin || 'undefined'}`);
    if (!origin || allowedOrigins.includes(origin)) {
      console.log(`CORS: Allowing origin ${origin || 'undefined'}`);
      callback(null, true);
    } else {
      console.warn(`CORS: Blocking origin ${origin}`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  methods: ['GET', 'POST', 'DELETE', 'OPTIONS', 'HEAD'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
  optionsSuccessStatus: 204,
}));

app.options('*', cors());

// Use /app for Render's filesystem
const uploadsDir = path.join('/app', 'Uploads');
const convertedDir = path.join('/app', 'converted');

// Ensure directories exist with correct permissions
(async () => {
  try {
    await fsPromises.mkdir(uploadsDir, { recursive: true, mode: 0o777 }); // Changed to 777 for LibreOffice
    await fsPromises.mkdir(convertedDir, { recursive: true, mode: 0o777 });
    console.log('Directories created:', { uploadsDir, convertedDir });
  } catch (err) {
    console.error('Error creating directories:', err.message);
    process.exit(1);
  }
})();

const upload = multer({
  dest: uploadsDir,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB limit
  fileFilter: (req, file, cb) => {
    const allFormats = [
      'bmp', 'eps', 'gif', 'ico', 'png', 'svg', 'tga', 'tiff', 'wbmp', 'webp', 'jpg', 'jpeg',
      'pdf', 'docx', 'txt', 'rtf', 'odt',
      'mp3', 'wav', 'aac', 'flac', 'ogg', 'opus', 'wma', 'aiff', 'm4v', 'mmf', '3g2',
      'mp4', 'avi', 'mov', 'webm', 'mkv', 'flv', 'wmv',
      'zip', '7z',
      'epub', 'mobi', 'azw3',
    ];
    const allowedExtensions = allFormats.map(ext => `.${ext}`);
    const ext = path.extname(file.originalname).toLowerCase();
    if (allowedExtensions.includes(ext)) {
      console.log(`File accepted: ${file.originalname} (${ext}, ${file.size} bytes)`);
      cb(null, true);
    } else {
      console.error(`Unsupported file type: ${ext} for ${file.originalname}`);
      cb(new Error(`Unsupported file type: ${ext}. Supported types: ${allFormats.join(', ')}`), false);
    }
  },
});

// Debug middleware to log all requests
app.use((req, res, next) => {
  console.log(`Route requested: ${req.method} ${req.originalUrl}`, {
    params: req.params,
    query: req.query,
    body: req.body
  });
  next();
});

// Register routes with logging
const routes = [
  { method: 'get', path: '/health' },
  { method: 'get', path: '/status' },
  { method: 'post', path: '/api/convert' },
  { method: 'get', path: '/converted/:filename' },
  { method: 'delete', path: '/api/delete/:filename' },
];

routes.forEach(({ method, path }) => {
  console.log(`Registering route: ${method.toUpperCase()} ${path}`);
});

app.get('/health', (req, res) => {
  console.log('Health check requested from:', req.get('origin'));
  res.status(200).json({ status: 'OK' });
});

app.get('/status', async (req, res) => {
  console.log('Status check requested from:', req.get('origin'));
  const checks = [
    {
      name: 'FFmpeg',
      check: () => new Promise((resolve) => {
        exec('ffmpeg -version', (err, stdout, stderr) => {
          if (err) {
            console.error('FFmpeg check failed:', err.message, stderr);
            return resolve({ name: 'FFmpeg', status: 'Failed', details: err.message });
          }
          console.log('FFmpeg version:', stdout.split('\n')[0]);
          resolve({ name: 'FFmpeg', status: 'OK', details: stdout.split('\n')[0] });
        });
      }),
    },
    {
      name: 'unoconv',
      check: () => new Promise((resolve) => {
        const librePath = process.env.LIBREOFFICE_PATH || '/usr/bin/unoconv';
        exec(`${librePath} --version`, (err, stdout, stderr) => {
          if (err) {
            console.error('unoconv check failed:', err.message, stderr);
            return resolve({ name: 'unoconv', status: 'Failed', details: err.message });
          }
          console.log('unoconv version:', stdout.split('\n')[0]);
          resolve({ name: 'unoconv', status: 'OK', details: stdout.split('\n')[0] });
        });
      }),
    },
    {
      name: 'LibreOffice',
      check: () => new Promise((resolve) => {
        exec('libreoffice --version', (err, stdout, stderr) => {
          if (err) {
            console.error('LibreOffice check failed:', err.message, stderr);
            return resolve({ name: 'LibreOffice', status: 'Failed', details: err.message });
          }
          console.log('LibreOffice version:', stdout.split('\n')[0]);
          resolve({ name: 'LibreOffice', status: 'OK', details: stdout.split('\n')[0] });
        });
      }),
    },
    {
      name: 'Ghostscript',
      check: () => new Promise((resolve) => {
        exec('gs --version', (err, stdout, stderr) => {
          if (err) {
            console.error('Ghostscript check failed:', err.message, stderr);
            return resolve({ name: 'Ghostscript', status: 'Failed', details: err.message });
          }
          console.log('Ghostscript version:', stdout.split('\n')[0]);
          resolve({ name: 'Ghostscript', status: 'OK', details: stdout.split('\n')[0] });
        });
      }),
    },
    {
      name: 'Calibre',
      check: () => new Promise((resolve) => {
        exec('ebook-convert --version', (err, stdout, stderr) => {
          if (err) {
            console.error('Calibre check failed:', err.message, stderr);
            return resolve({ name: 'Calibre', status: 'Failed', details: err.message });
          }
          console.log('Calibre version:', stdout.split('\n')[0]);
          resolve({ name: 'Calibre', status: 'OK', details: stdout.split('\n')[0] });
        });
      }),
    },
  ];

  Promise.all(checks.map(c => c.check())).then(results => {
    res.status(200).json({ status: 'OK', dependencies: results });
  });
});

const allFormats = [
  'bmp', 'eps', 'gif', 'ico', 'png', 'svg', 'tga', 'tiff', 'wbmp', 'webp', 'jpg', 'jpeg',
  'pdf', 'docx', 'txt', 'rtf', 'odt',
  'mp3', 'wav', 'aac', 'flac', 'ogg', 'opus', 'wma', 'aiff', 'm4v', 'mmf', '3g2',
  'mp4', 'avi', 'mov', 'webm', 'mkv', 'flv', 'wmv',
  'zip', '7z',
  'epub', 'mobi', 'azw3',
];

const supportedFormats = {
  image: allFormats,
  compressor: ['jpg', 'png', 'svg'],
  pdfs: allFormats,
  audio: allFormats,
  video: allFormats,
  document: allFormats,
  archive: allFormats,
  ebook: allFormats,
};

// Sanitize filename to prevent invalid characters
const sanitizeFilename = (filename) => {
  return filename
    .replace(/[^a-zA-Z0-9-_.]/g, '') // Remove invalid characters
    .replace(/\s+/g, '_') // Replace spaces with underscores
    .slice(0, 100); // Limit filename length
};

app.post('/api/convert', upload.array('files', 5), async (req, res) => {
  console.log('Received /api/convert request from:', req.get('origin'), {
    files: req.files ? req.files.map(f => ({ name: f.originalname, size: f.size, path: f.path })) : [],
    formats: req.body.formats,
  });
  let tempFiles = req.files ? req.files.map(f => f.path) : [];
  try {
    const files = req.files;
    let formats;
    try {
      formats = JSON.parse(req.body.formats || '[]');
    } catch (parseError) {
      console.error('Error parsing formats:', parseError);
      return res.status(400).json({ error: 'Invalid formats data. Please provide valid JSON.' });
    }
    if (!files || files.length === 0) {
      console.error('No files uploaded');
      return res.status(400).json({ error: 'No files uploaded.' });
    }
    if (files.length > 5) {
      console.error('Too many files uploaded');
      return res.status(400).json({ error: 'Maximum 5 files allowed.' });
    }
    if (files.length !== formats.length) {
      console.error(`Mismatch between files (${files.length}) and formats (${formats.length})`);
      return res.status(400).json({
        error: `Mismatch between files and formats. Files: ${files.length}, Formats: ${formats.length}`,
      });
    }
    const outputFiles = [];
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const formatInfo = formats[i];
      const inputExt = path.extname(file.originalname).toLowerCase().slice(1) || 'unknown';
      const outputExt = formatInfo.target.toLowerCase().split(' ')[0];
      console.log(`Processing file: ${file.originalname}, type: ${formatInfo.type}, inputExt: ${inputExt}, target: ${outputExt}`);
      if (!Object.keys(supportedFormats).includes(formatInfo.type)) {
        throw new Error(`Unsupported conversion type: ${formatInfo.type}. Supported types: ${Object.keys(supportedFormats).join(', ')}`);
      }
      if (!supportedFormats[formatInfo.type].includes(outputExt)) {
        throw new Error(`Unsupported output format: ${outputExt} for type ${formatInfo.type}. Supported formats: ${supportedFormats[formatInfo.type].join(', ')}`);
      }
      if (!allFormats.includes(inputExt)) {
        throw new Error(`Unsupported input format: ${inputExt}. Supported formats: ${allFormats.join(', ')}`);
      }
      const inputPath = file.path;
      const outputPath = path.join(
        convertedDir,
        `${sanitizeFilename(path.basename(file.originalname, path.extname(file.originalname)))}_${Date.now()}.${outputExt}`
      );
      try {
        await fsPromises.access(inputPath);
      } catch {
        throw new Error(`Input file not found: ${file.originalname}`);
      }
      const outputType = ['bmp', 'eps', 'gif', 'ico', 'png', 'svg', 'tga', 'tiff', 'wbmp', 'webp', 'jpg', 'jpeg'].includes(outputExt) ? 'image' :
        ['pdf', 'docx', 'txt', 'rtf', 'odt'].includes(outputExt) ? 'document' :
        ['mp3', 'wav', 'aac', 'flac', 'ogg', 'opus', 'wma', 'aiff', 'm4v', 'mmf', '3g2'].includes(outputExt) ? 'audio' :
        ['mp4', 'avi', 'mov', 'webm', 'mkv', 'flv', 'wmv'].includes(outputExt) ? 'video' : formatInfo.type;
      switch (outputType) {
        case 'image':
        case 'compressor':
          await convertImage(inputPath, outputPath, outputExt, formatInfo.subSection);
          break;
        case 'document':
          await convertDocument(inputPath, outputPath, outputExt);
          break;
        case 'pdfs':
          await convertPdf(inputPath, outputPath, outputExt);
          break;
        case 'audio':
        case 'video':
          await convertMedia(inputPath, outputPath, outputExt, inputExt);
          break;
        case 'archive':
          await convertArchive(inputPath, outputPath, outputExt);
          break;
        case 'ebook':
          await convertEbook(inputPath, outputPath, outputExt);
          break;
        default:
          throw new Error(`Unsupported conversion type: ${outputType}`);
      }
      outputFiles.push({
        path: outputPath,
        name: path.basename(outputPath),
        id: formatInfo.id,
      });
    }
    res.json({
      files: outputFiles.map(file => ({
        name: file.name,
        path: `/converted/${encodeURIComponent(file.name)}`,
        id: file.id,
      })),
    });
  } catch (error) {
    console.error('Conversion error:', { message: error.message, stack: error.stack });
    res.status(500).json({ error: error.message || 'Conversion failed. Please try a different PDF or check server logs.' });
  } finally {
    await cleanupFiles(tempFiles.filter(file => file.startsWith(uploadsDir)));
  }
});

app.get('/converted/:filename([a-zA-Z0-9-_.]+)', async (req, res) => {
  const filename = req.params.filename;
  const filePath = path.join(convertedDir, filename);
  console.log(`Serving file: ${filePath} to ${req.get('origin')}`);
  try {
    await fsPromises.access(filePath);
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.sendFile(filePath, (err) => {
      if (err) {
        console.error('Error sending file:', err);
        res.status(500).json({ error: 'Failed to send converted file.' });
      } else {
        console.log(`File sent successfully: ${filePath}`);
      }
    });
  } catch (err) {
    console.error('File not found:', filePath, err);
    res.status(404).json({ error: 'Converted file not found.' });
  }
});

app.delete('/api/delete/:filename([a-zA-Z0-9-_.]+)', async (req, res) => {
  const filename = req.params.filename;
  const filePath = path.join(convertedDir, filename);
  console.log(`Delete request for ${filePath} from ${req.get('origin')}`);
  try {
    await cleanupFiles([filePath]);
    res.status(200).json({ message: `File ${filename} deleted successfully.` });
  } catch (err) {
    console.error(`Error deleting file ${filePath}:`, err);
    res.status(500).json({ error: `Failed to delete file ${filename}.` });
  }
});

async function convertImage(inputPath, outputPath, format, subSection) {
  const imageFormats = ['bmp', 'eps', 'gif', 'ico', 'png', 'svg', 'tga', 'tiff', 'wbmp', 'webp', 'jpg', 'jpeg'];
  const inputExt = path.extname(inputPath).toLowerCase().slice(1);
  const sharpSupported = ['bmp', 'gif', 'png', 'tiff', 'webp', 'jpg', 'jpeg'];
  if (!imageFormats.includes(inputExt) && ['pdf', 'docx', 'txt', 'rtf', 'odt'].includes(inputExt)) {
    const tempPdfPath = path.join(convertedDir, `temp_${Date.now()}.pdf`);
    try {
      await convertDocument(inputPath, tempPdfPath, 'pdf');
      await convertImage(tempPdfPath, outputPath, format, subSection);
      await fsPromises.unlink(tempPdfPath).catch(err => console.error(`Error cleaning up temp PDF: ${err.message}`));
    } catch (err) {
      console.error(`Image conversion preprocessing failed: ${err.message}`);
      throw err;
    }
    return;
  }
  if (imageFormats.includes(format)) {
    if (subSection === 'compressor' && format === 'svg') {
      const svgData = await fsPromises.readFile(inputPath, 'utf-8');
      const result = optimize(svgData, {
        multipass: true,
        plugins: [{ name: 'preset-default' }, { name: 'removeViewBox', active: false }],
      });
      if (result.error) {
        throw new Error(`SVG compression failed: ${result.error}`);
      }
      await fsPromises.writeFile(outputPath, result.data);
      console.log(`SVG compression completed: ${outputPath}`);
    } else if (sharpSupported.includes(format)) {
      let sharpInstance = sharp(inputPath);
      if (subSection === 'compressor') {
        if (format === 'jpg' || format === 'jpeg') {
          sharpInstance = sharpInstance.jpeg({ quality: 80 });
        } else if (format === 'png') {
          sharpInstance = sharpInstance.png({ compressionLevel: 9 });
        }
      }
      await sharpInstance
        .toFormat(format === 'jpg' ? 'jpeg' : format)
        .toFile(outputPath);
      console.log(`Image conversion (Sharp) completed: ${outputPath}`);
    } else {
      throw new Error(`Unsupported image format for Sharp: ${format}. Please use a supported format: ${sharpSupported.join(', ')}`);
    }
  } else if (format === 'pdf') {
    await new Promise((resolve, reject) => {
      const doc = new PDFDocument();
      const stream = fs.createWriteStream(outputPath);
      doc.pipe(stream);
      doc.image(inputPath, { fit: [595, 842] });
      doc.end();
      stream.on('finish', () => {
        console.log(`Image to PDF conversion completed: ${outputPath}`);
        resolve();
      });
      stream.on('error', (err) => {
        console.error(`Image to PDF conversion failed: ${err.message}`);
        reject(new Error(`Image to PDF conversion failed: ${err.message}`));
      });
    });
  } else {
    throw new Error(`Unsupported image output format: ${format}`);
  }
}

async function convertPdf(inputPath, outputPath, format) {
  const inputExt = path.extname(inputPath).toLowerCase().slice(1);
  if (inputExt !== 'pdf') {
    const tempPdfPath = path.join(convertedDir, `temp_${Date.now()}.pdf`);
    try {
      await convertDocument(inputPath, tempPdfPath, 'pdf');
      await convertPdf(tempPdfPath, outputPath, format);
      await fsPromises.unlink(tempPdfPath).catch(err => console.error(`Error cleaning up temp PDF: ${err.message}`));
    } catch (err) {
      console.error(`PDF conversion preprocessing failed: ${err.message}`);
      throw err;
    }
    return;
  }
  if (['jpg', 'png', 'gif'].includes(format)) {
    try {
      const output = fromPath(inputPath, {
        density: 100,
        format: format,
        outputDir: path.dirname(outputPath),
        outputName: path.basename(outputPath, `.${format}`)
      });
      await output.bulk(-1);
      console.log(`PDF to ${format} conversion completed: ${outputPath}`);
    } catch (err) {
      console.error(`PDF to ${format} conversion failed: ${err.message}`);
      throw new Error(`PDF to ${format} conversion failed: ${err.message}`);
    }
  } else if (['docx', 'txt', 'rtf', 'odt'].includes(format)) {
    await convertDocument(inputPath, outputPath, format);
  } else {
    throw new Error(`Unsupported PDF output format: ${format}`);
  }
}

async function convertDocument(inputPath, outputPath, format) {
  const inputExt = path.extname(inputPath).toLowerCase().slice(1);
  const supportedDocumentFormats = ['docx', 'pdf', 'txt', 'rtf', 'odt'];
  
  // Pre-processing for non-document files
  if (['bmp', 'eps', 'gif', 'ico', 'png', 'svg', 'tga', 'tiff', 'wbmp', 'webp', 'jpg', 'jpeg'].includes(inputExt)) {
    const tempPdfPath = path.join(convertedDir, `temp_${Date.now()}.pdf`);
    try {
      await convertImage(inputPath, tempPdfPath, 'pdf', 'image');
      await convertDocument(tempPdfPath, outputPath, format);
      await fsPromises.unlink(tempPdfPath).catch(err => console.error(`Error cleaning up temp PDF: ${err.message}`));
      return;
    } catch (err) {
      console.error(`Document conversion preprocessing failed: ${err.message}`);
      throw err;
    }
  }

  if (!supportedDocumentFormats.includes(format)) {
    throw new Error(`Unsupported output document format: ${format}`);
  }

  // Try multiple conversion methods with fallbacks
  try {
    // Method 1: unoconv (primary)
    await tryUnoconvConversion(inputPath, outputPath, format);
    return;
  } catch (unoconvError) {
    console.warn(`unoconv failed, trying alternative methods: ${unoconvError.message}`);
  }

  try {
    // Method 2: libreoffice-convert
    await tryLibreOfficeConvert(inputPath, outputPath, format);
    return;
  } catch (libreError) {
    console.warn(`libreoffice-convert failed: ${libreError.message}`);
  }

  try {
    // Method 3: pdftodoc (fallback)
    if (format === 'docx') {
      await tryPdfToDoc(inputPath, outputPath);
      return;
    }
  } catch (pdftodocError) {
    console.warn(`pdftodoc failed: ${pdftodocError.message}`);
  }

  // Final fallback: Ghostscript + Pandoc if available
  try {
    await tryGhostscriptPandoc(inputPath, outputPath, format);
    return;
  } catch (finalError) {
    console.error(`All conversion methods failed: ${finalError.message}`);
    throw new Error(`Document conversion failed after all attempts. The file may be encrypted or corrupted.`);
  }
}

// Helper functions for different conversion methods
async function tryUnoconvConversion(inputPath, outputPath, format) {
  const command = `unoconv -f ${format} -o "${outputPath}" "${inputPath}"`;
  console.log(`Attempting unoconv conversion: ${command}`);
  
  const { stdout, stderr } = await execPromise(command, { 
    timeout: 180000,
    env: {
      ...process.env,
      HOME: '/home/officeuser', // Set HOME for unoconv
      USER: 'officeuser'
    }
  });
  
  if (stderr) console.warn(`unoconv stderr: ${stderr}`);
  console.log(`unoconv conversion succeeded: ${outputPath}`);
}

async function tryLibreOfficeConvert(inputPath, outputPath, format) {
  console.log(`Attempting libreoffice-convert for ${format}`);
  
  const inputBuf = await fsPromises.readFile(inputPath);
  await new Promise((resolve, reject) => {
    libre.convert(inputBuf, format, undefined, (err, outputBuf) => {
      if (err) return reject(err);
      fsPromises.writeFile(outputPath, outputBuf)
        .then(resolve)
        .catch(reject);
    });
  });
  console.log(`libreoffice-convert succeeded: ${outputPath}`);
}

async function tryPdfToDoc(inputPath, outputPath) {
  console.log(`Attempting pdftodoc conversion`);
  
  const tempDir = await fsPromises.mkdtemp(path.join(os.tmpdir(), 'pdftodoc-'));
  const tempHtmlPath = path.join(tempDir, 'output.html');
  
  // First convert PDF to HTML
  await execPromise(`pdftohtml -c -noframes "${inputPath}" "${tempHtmlPath}"`);
  
  // Then convert HTML to DOCX using pandoc if available
  try {
    await execPromise(`pandoc -s "${tempHtmlPath}" -o "${outputPath}"`);
  } catch {
    // Fallback to simple copy if pandoc not available
    await fsPromises.copyFile(tempHtmlPath, outputPath);
  }
  
  // Cleanup
  await fsPromises.rm(tempDir, { recursive: true });
  console.log(`pdftodoc conversion succeeded: ${outputPath}`);
}

async function tryGhostscriptPandoc(inputPath, outputPath, format) {
  console.log(`Attempting Ghostscript+Pandoc conversion`);
  
  const tempDir = await fsPromises.mkdtemp(path.join(os.tmpdir(), 'gs-'));
  const tempPdfPath = path.join(tempDir, 'processed.pdf');
  
  // Use Ghostscript to process the PDF
  await execPromise(`gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile="${tempPdfPath}" "${inputPath}"`);
  
  // Then convert to target format using Pandoc
  await execPromise(`pandoc "${tempPdfPath}" -o "${outputPath}"`);
  
  // Cleanup
  await fsPromises.rm(tempDir, { recursive: true });
  console.log(`Ghostscript+Pandoc conversion succeeded: ${outputPath}`);
}

async function convertMedia(inputPath, outputPath, format, inputExt) {
  const supportedAudioFormats = ['aac', 'aiff', 'flac', 'm4v', 'mmf', 'ogg', 'opus', 'wav', 'wma', '3g2', 'mp3'];
  const supportedVideoFormats = ['mp4', 'avi', 'mov', 'webm', 'mkv', 'flv', 'wmv', '3g2'];
  if (!supportedAudioFormats.includes(format) && !supportedVideoFormats.includes(format)) {
    throw new Error(`Unsupported media output format: ${format}`);
  }
  try {
    await new Promise((resolve, reject) => {
      const ffmpegInstance = ffmpeg(inputPath);
      const isAudioInput = ['mp3', 'wav', 'aac', 'flac', 'ogg', 'opus', 'wma', 'aiff', 'mmf'].includes(inputExt);
      const isVideoOutput = supportedVideoFormats.includes(format);

      if (isVideoOutput && isAudioInput) {
        ffmpegInstance
          .input('color=c=black:s=320x240:r=25')
          .inputFormat('lavfi')
          .videoCodec('mpeg4')
          .audioCodec('aac')
          .outputOptions('-shortest', '-threads 1', '-preset ultrafast');
      } else {
        if (format === 'aac') {
          ffmpegInstance.audioCodec('aac');
        } else if (format === 'wma') {
          ffmpegInstance.audioCodec('wmav2');
        } else if (format === 'm4v' || format === '3g2') {
          ffmpegInstance
            .videoCodec('mpeg4')
            .audioCodec('aac');
        } else if (format === 'mmf') {
          ffmpegInstance.audioCodec('pcm_s16le');
        } else if (supportedVideoFormats.includes(format)) {
          ffmpegInstance
            .videoCodec('libx264')
            .audioCodec('aac');
        }
      }

      ffmpegInstance
        .outputOptions('-threads 1', '-preset ultrafast')
        .toFormat(format)
        .on('start', (cmd) => console.log(`FFmpeg command: ${cmd}`))
        .on('progress', (progress) => console.log(`Processing: ${progress.percent}% done`))
        .on('end', () => {
          console.log(`Media conversion completed: ${outputPath}`);
          resolve();
        })
        .on('error', (err, stdout, stderr) => {
          console.error(`Fluent-FFmpeg conversion error for ${format}: ${err.message}`, { stdout, stderr });
          reject(err);
        })
        .save(outputPath);
    });
  } catch (err) {
    console.warn(`Fluent-FFmpeg failed, falling back to direct FFmpeg: ${err.message}`);
    await new Promise((resolve, reject) => {
      const cmd = `ffmpeg -i "${inputPath}" -threads 1 -preset ultrafast "${outputPath}"`;
      exec(cmd, (err, stdout, stderr) => {
        if (err) {
          console.error(`Direct FFmpeg conversion failed for ${format}: ${err.message}`, { stdout, stderr });
          return reject(new Error(`Media conversion failed: ${err.message}`));
        }
        console.log(`Direct FFmpeg conversion completed: ${outputPath}`);
        resolve();
      });
    });
  }
}

async function convertArchive(inputPath, outputPath, format) {
  if (format === 'zip' || format === '7z') {
    return new Promise((resolve, reject) => {
      sevenZip.add(outputPath, inputPath, { $raw: { '-t': format } })
        .on('end', () => {
          console.log(`Archive conversion completed: ${outputPath}`);
          resolve();
        })
        .on('error', (err) => {
          console.error(`Archive conversion error: ${err.message}`);
          reject(new Error(`Archive conversion failed: ${err.message}`));
        });
    });
  } else {
    throw new Error(`Unsupported archive format: ${format}`);
  }
}

async function convertEbook(inputPath, outputPath, format) {
  return new Promise((resolve, reject) => {
    exec(`ebook-convert "${inputPath}" "${outputPath}"`, (err, stdout, stderr) => {
      if (err) {
        console.error(`Ebook conversion error: ${err.message}`, { stdout, stderr });
        return reject(new Error(`Ebook conversion failed: ${err.message}`));
      }
      console.log(`Ebook conversion completed: ${outputPath}`);
      resolve();
    });
  });
}

async function cleanupFiles(filePaths) {
  const maxRetries = 3;
  const retryDelay = 1000;
  const cleanupPromises = filePaths.map(async (filePath) => {
    let attempts = 0;
    while (attempts < maxRetries) {
      try {
        await fsPromises.access(filePath);
        await fsPromises.unlink(filePath);
        console.log(`Deleted file: ${filePath}`);
        return;
      } catch (err) {
        if (err.code === 'ENOENT') {
          console.log(`File not found for deletion: ${filePath}`);
          return;
        }
        if (err.code === 'EPERM') {
          attempts++;
          console.warn(`EPERM error on attempt ${attempts} for ${filePath}. Retrying in ${retryDelay}ms...`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
          if (attempts === maxRetries) {
            console.error(`Failed to delete file ${filePath} after ${maxRetries} attempts: ${err.message}`);
          }
        } else {
          console.error(`Error deleting file ${filePath}:`, err);
          break;
        }
      }
    }
  });
  await Promise.all(cleanupPromises);
}

app.listen(port, '0.0.0.0', () => {
  console.log(`Server running on http://0.0.0.0:${port}`);
});

i have frontend folder in that i have src folder in that i have components folder in that i have Dropbox.tsx file 
import React, { useEffect, useRef, useState } from "react";
import { FaFolderOpen, FaDropbox, FaGoogleDrive } from "react-icons/fa";
import { FiArrowRight, FiDownload } from "react-icons/fi";

declare global {
  interface Window {
    Dropbox: any;
    gapi: any;
    google: any;
    onApiLoad?: () => void;
  }
}

interface FileItem {
  file: File;
  showMenu: boolean;
  section: keyof FormatOptions;
  selectedFormat: string;
  source?: string;
  url?: string;
  id: string;
  selectedSubSection?: string;
}

interface FormatOptions {
  image: {
    image: string[];
    compressor: string[];
    pdf: string[];
  };
  pdfs: {
    document: string[];
    compressor: string[];
    ebook: string[];
    pdf_ebook: string[];
    pdf_to_image: string[];
  };
  audio: {
    audio: string[];
  };
  video: {
    audio: string[];
    device: string[];
    video: string[];
    compressor: string[];
    webservice: string[];
  };
  document: string[];
  archive: string[];
  ebook: string[];
}

interface ConvertedFile {
  name: string;
  url: string;
  loading: boolean;
  originalId: string;
}

export default function Dropbox() {
  const GOOGLE_CLIENT_ID = import.meta.env.VITE_GOOGLE_CLIENT_ID!;
  const GOOGLE_API_KEY = import.meta.env.VITE_GOOGLE_API_KEY!;
  const API_URL = import.meta.env.VITE_API_URL || "http://localhost:5001";

  const fileInputRef = useRef<HTMLInputElement>(null);
  const pickerLoaded = useRef(false);
  const [selectedFiles, setSelectedFiles] = useState<FileItem[]>([]);
  const [isConverting, setIsConverting] = useState(false);
  const [convertedFiles, setConvertedFiles] = useState<ConvertedFile[]>([]);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  useEffect(() => {
    const loadGoogleApiScript = () => {
      if (!document.querySelector('script[src="https://apis.google.com/js/api.js"]')) {
        const script = document.createElement("script");
        script.src = "https://apis.google.com/js/api.js";
        script.async = true;
        script.onload = () => {
          console.log("Google API script loaded");
          initializeGoogleApi();
        };
        script.onerror = () => {
          console.error("Failed to load Google API script");
          setErrorMessage("Failed to load Google API script. Please check your network or browser settings.");
        };
        document.body.appendChild(script);
      } else {
        initializeGoogleApi();
      }
    };

    const initializeGoogleApi = async () => {
      if (!window.gapi) {
        console.error("Google API (gapi) not available");
        setErrorMessage("Google API not available. Retrying in 5 seconds...");
        setTimeout(initializeGoogleApi, 5000);
        return;
      }
      try {
        window.onApiLoad = () => {
          window.gapi.load("client:auth2", async () => {
            try {
              await window.gapi.client.init({
                apiKey: GOOGLE_API_KEY,
                clientId: GOOGLE_CLIENT_ID,
                scope: "https://www.googleapis.com/auth/drive.readonly",
                discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"],
                prompt: "select_account",
              });
              console.log("Google API client initialized");
              window.gapi.load("picker", {
                callback: () => {
                  if (window.google?.picker) {
                    pickerLoaded.current = true;
                    console.log("Google Picker API loaded");
                  } else {
                    console.error("Google Picker API not available");
                    setErrorMessage("Google Picker API failed to load. Please try again or check your Google API credentials.");
                  }
                },
              });
            } catch (err) {
              console.error("Google API initialization failed:", err);
              setErrorMessage("Failed to initialize Google API. Check your API key, client ID, or browser settings (e.g., enable third-party cookies).");
            }
          });
        };
        window.onApiLoad();
      } catch (err) {
        console.error("Error setting up Google API:", err);
        setErrorMessage("Failed to set up Google API. Check your network or browser settings.");
      }
    };

    loadGoogleApiScript();

    return () => {
      convertedFiles.forEach(file => window.URL.revokeObjectURL(file.url));
      delete window.onApiLoad;
    };
  }, [convertedFiles, GOOGLE_API_KEY, GOOGLE_CLIENT_ID]);

  const handleLocalFileClick = () => fileInputRef.current?.click();

  const handleLocalFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      if (selectedFiles.length + files.length > 5) {
        setErrorMessage("Maximum 5 files allowed.");
        return;
      }
      const largeFiles = Array.from(files).filter(f => f.size > 50 * 1024 * 1024);
      if (largeFiles.length > 0) {
        setErrorMessage(`Files too large: ${largeFiles.map(f => f.name).join(', ')}. Maximum size is 50MB per file.`);
        return;
      }
      const newFiles = Array.from(files).map((f) => {
        const ext = f.name.split('.').pop()?.toLowerCase() || '';
        const section = ext === 'pdf' ? 'pdfs' :
          ['bmp', 'eps', 'gif', 'ico', 'png', 'svg', 'tga', 'tiff', 'wbmp', 'webp', 'jpg', 'jpeg'].includes(ext) ? 'image' :
            ['doc', 'docx', 'txt', 'rtf', 'odt', 'html', 'ppt', 'pptx', 'xlsx'].includes(ext) ? 'document' :
              ['mp3', 'wav', 'aac', 'flac', 'ogg', 'opus', 'wma', 'aiff', 'm4v', 'mmf', '3g2'].includes(ext) ? 'audio' :
                ['mp4', 'avi', 'mov', 'webm', 'mkv', 'flv', 'wmv', '3gp', 'mpg', 'ogv'].includes(ext) ? 'video' :
                  ['zip', '7z'].includes(ext) ? 'archive' :
                    ['epub', 'mobi', 'azw3', 'fb2', 'lit', 'lrf', 'pdb', 'tcr'].includes(ext) ? 'ebook' : 'image';
        return {
          file: f,
          showMenu: false,
          section: section as keyof FormatOptions,
          selectedFormat: "",
          source: 'local',
          id: `${f.name}_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`,
        };
      });
      setSelectedFiles((prev) => [...prev, ...newFiles]);
      setConvertedFiles([]);
      setErrorMessage(null);
      if (fileInputRef.current) fileInputRef.current.value = '';
    }
  };

  const handleDropboxUpload = () => {
    if (!window.Dropbox) {
      setErrorMessage("Dropbox SDK not loaded.");
      return;
    }
    window.Dropbox.choose({
      linkType: "direct",
      multiselect: true,
      extensions: [
        '.mp3', '.wav', '.aac', '.flac', '.ogg', '.opus', '.wma', '.aiff', '.m4v', '.mmf', '.3g2',
        '.mp4', '.avi', '.mov', '.webm', '.mkv', '.flv', '.wmv', '.3gp', '.mpg', '.ogv',
        '.png', '.jpg', '.jpeg', '.webp', '.svg', '.bmp', '.gif', '.ico', '.tga', '.tiff', '.wbmp',
        '.pdf', '.doc', '.docx', '.txt', '.rtf', '.odt', '.html', '.ppt', '.pptx', '.xlsx',
        '.zip', '.7z',
        '.epub', '.mobi', '.azw3', '.fb2', '.lit', '.lrf', '.pdb', '.tcr',
      ],
      success: async (files: any[]) => {
        if (selectedFiles.length + files.length > 5) {
          setErrorMessage("Maximum 5 files allowed.");
          return;
        }
        const newFiles = await Promise.all(files.map(async (f) => {
          try {
            const response = await fetch(f.link);
            if (!response.ok) throw new Error(`Failed to fetch Dropbox file: ${f.name}`);
            const blob = await response.blob();
            if (blob.size > 50 * 1024 * 1024) {
              console.error(`File too large: ${f.name} (${blob.size} bytes)`);
              return null;
            }
            const ext = f.name.split('.').pop()?.toLowerCase() || '';
            const section = ext === 'pdf' ? 'pdfs' :
              ['bmp', 'eps', 'gif', 'ico', 'png', 'svg', 'tga', 'tiff', 'wbmp', 'webp', 'jpg', 'jpeg'].includes(ext) ? 'image' :
                ['doc', 'docx', 'txt', 'rtf', 'odt', 'html', 'ppt', 'pptx', 'xlsx'].includes(ext) ? 'document' :
                  ['mp3', 'wav', 'aac', 'flac', 'ogg', 'opus', 'wma', 'aiff', 'm4v', 'mmf', '3g2'].includes(ext) ? 'audio' :
                    ['mp4', 'avi', 'mov', 'webm', 'mkv', 'flv', 'wmv', '3gp', 'mpg', 'ogv'].includes(ext) ? 'video' :
                      ['zip', '7z'].includes(ext) ? 'archive' :
                        ['epub', 'mobi', 'azw3', 'fb2', 'lit', 'lrf', 'pdb', 'tcr'].includes(ext) ? 'ebook' : 'image';
            return {
              file: new File([blob], f.name, { type: blob.type }),
              showMenu: false,
              section: section as keyof FormatOptions,
              selectedFormat: "",
              source: 'dropbox',
              url: f.link,
              id: `${f.name}_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`,
            };
          } catch (err) {
            console.error(`Error fetching Dropbox file ${f.name}:`, err);
            return null;
          }
        }));
        const validFiles = newFiles.filter(f => f !== null) as FileItem[];
        if (newFiles.some(f => f === null)) {
          setErrorMessage("Some Dropbox files were too large or failed to load. Maximum size is 50MB per file.");
        }
        setSelectedFiles((prev) => [...prev, ...validFiles]);
        setConvertedFiles([]);
        if (validFiles.length > 0) setErrorMessage(null);
      },
      error: (err: any) => {
        console.error("Dropbox picker error:", err);
        setErrorMessage("Failed to load files from Dropbox.");
      },
    });
  };

  const handleGoogleDriveUpload = () => {
    if (!pickerLoaded.current) {
      console.warn("Google Picker not loaded yet. Attempting to initialize...");
      setErrorMessage("Google Picker is not ready. Please try again in a moment.");
      window.gapi?.load("picker", {
        callback: () => {
          if (window.google?.picker) {
            pickerLoaded.current = true;
            console.log("Google Picker API loaded on retry");
            triggerGoogleSignIn();
          } else {
            console.error("Google Picker API failed to load on retry");
            setErrorMessage("Google Picker failed to load. Please refresh the page.");
          }
        },
      });
      return;
    }
    triggerGoogleSignIn();
  };

  const triggerGoogleSignIn = async () => {
    if (!window.gapi?.auth2) {
      console.error("Google auth2 not available");
      setErrorMessage("Google authentication service not available. Retrying in 5 seconds...");
      setTimeout(triggerGoogleSignIn, 5000);
      return;
    }
    try {
      const auth2 = window.gapi.auth2.getAuthInstance();
      const googleUser = await auth2.signIn({
        prompt: "select_account consent",
        scope: "https://www.googleapis.com/auth/drive.readonly",
      });
      const token = googleUser.getAuthResponse().access_token;
      console.log("Google Sign-in successful, access token:", token);
      createGooglePicker(token);
    } catch (err: any) {
      console.error("Google Sign-in failed:", err);
      if (err.error === "idpiframe_initialization_failed") {
        setErrorMessage("Google Sign-in failed: Third-party cookies are blocked. Please enable cookies in your browser settings or try a different browser.");
      } else if (err.error === "IdentityCredentialError") {
        setErrorMessage("Google Sign-in failed: Unable to retrieve token. Check your credentials or try again.");
      } else {
        setErrorMessage(`Google Sign-in failed: ${err.error || "Unknown error"}. Please check your credentials or try again.`);
      }
    }
  };

  const createGooglePicker = async (token: string) => {
    if (pickerLoaded.current && token && window.google?.picker) {
      console.log("Creating Google Picker with token:", token);
      const picker = new window.google.picker.PickerBuilder()
        .addView(window.google.picker.ViewId.DOCS)
        .setOAuthToken(token)
        .setDeveloperKey(GOOGLE_API_KEY)
        .setCallback(async (data: any) => {
          if (data.action === window.google.picker.Action.PICKED) {
            console.log("Files picked from Google Drive:", data.docs);
            if (selectedFiles.length + data.docs.length > 5) {
              setErrorMessage("Maximum 5 files allowed.");
              return;
            }
            const newFiles = await Promise.all(data.docs.map(async (doc: any) => {
              try {
                const response = await fetch(
                  `https://www.googleapis.com/drive/v3/files/${doc.id}?alt=media`,
                  {
                    headers: { Authorization: `Bearer ${token}` },
                  }
                );
                if (!response.ok) throw new Error(`Failed to fetch Google Drive file: ${doc.name}`);
                const blob = await response.blob();
                if (blob.size > 50 * 1024 * 1024) {
                  console.error(`File too large: ${doc.name} (${blob.size} bytes)`);
                  return null;
                }
                const ext = doc.name.split('.').pop()?.toLowerCase() || '';
                const section = ext === 'pdf' ? 'pdfs' :
                  ['bmp', 'eps', 'gif', 'ico', 'png', 'svg', 'tga', 'tiff', 'wbmp', 'webp', 'jpg', 'jpeg'].includes(ext) ? 'image' :
                    ['doc', 'docx', 'txt', 'rtf', 'odt', 'html', 'ppt', 'pptx', 'xlsx'].includes(ext) ? 'document' :
                      ['mp3', 'wav', 'aac', 'flac', 'ogg', 'opus', 'wma', 'aiff', 'm4v', 'mmf', '3g2'].includes(ext) ? 'audio' :
                        ['mp4', 'avi', 'mov', 'webm', 'mkv', 'flv', 'wmv', '3gp', 'mpg', 'ogv'].includes(ext) ? 'video' :
                          ['zip', '7z'].includes(ext) ? 'archive' :
                            ['epub', 'mobi', 'azw3', 'fb2', 'lit', 'lrf', 'pdb', 'tcr'].includes(ext) ? 'ebook' : 'image';
                return {
                  file: new File([blob], doc.name, { type: blob.type }),
                  showMenu: false,
                  section: section as keyof FormatOptions,
                  selectedFormat: "",
                  source: 'google',
                  url: doc.url,
                  id: `${doc.name}_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`,
                };
              } catch (err) {
                console.error(`Error fetching Google Drive file ${doc.name}:`, err);
                return null;
              }
            }));
            const validFiles = newFiles.filter(f => f !== null) as FileItem[];
            if (newFiles.some(f => f === null)) {
              setErrorMessage("Some Google Drive files were too large or failed to load. Maximum size is 50MB per file.");
            }
            setSelectedFiles((prev) => [...prev, ...validFiles]);
            setConvertedFiles([]);
            if (validFiles.length > 0) setErrorMessage(null);
          }
        })
        .build();
      picker.setVisible(true);
    } else {
      console.error("Cannot create Google Picker. PickerLoaded:", pickerLoaded.current, "Token:", !!token, "Google Picker:", !!window.google?.picker);
      setErrorMessage("Failed to create Google Picker. Please try again.");
    }
  };

  const formatOptions: FormatOptions = {
    image: {
      image: ["BMP", "EPS", "GIF", "ICO", "JPG", "SVG", "TGA", "TIFF", "WBMP", "WEBP"],
      compressor: ["JPG Image Compress", "PNG Image Compress", "SVG Image Compress"],
      pdf: ["IMAGES TO PDF"],
    },
    pdfs: {
      document: ["DOCX", "HTML", "ODT", "RTF", "TXT", "XLSX"],
      compressor: ["PDF Document Compress"],
      ebook: ["AZW3", "EPUB", "FB2", "MOBI"],
      pdf_ebook: ["AZW3", "EPUB", "FB2", "MOBI"],
      pdf_to_image: ["JPG", "PNG", "GIF"],
    },
    audio: {
      audio: ["AAC", "AIFF", "FLAC", "M4V", "MMF", "OGG", "OPUS", "WAV", "WMA", "3G2"],
    },
    video: {
      audio: ["AAC", "AIFF", "FLAC", "M4V", "MMF", "MP3", "OGG", "OPUS", "WAV", "WMA", "3G2"],
      device: ["ANDROID", "BLACKBERRY", "IPAD", "IPHONE", "IPOD", "PLAYSTATION", "PSP", "WII", "XBOX"],
      video: ["3G2", "3GP", "AVI", "FLV", "MKV", "MOV", "MPG", "OGV", "WEBM", "WMV"],
      compressor: ["MP4 Video Compress"],
      webservice: ["DAILYMOTION", "FACEBOOK", "INSTAGRAM", "TELEGRAM", "TWITCH", "TWITTER", "VIBER", "VIMEO", "WHATSAPP", "YOUTUBE"],
    },
    document: ["DOCX", "PDF", "TXT", "RTF", "ODT"],
    archive: ["ZIP", "7Z"],
    ebook: ["EPUB", "MOBI", "PDF", "AZW3"],
  };

  const toggleMenu = (index: number) => {
    setSelectedFiles((prev) =>
      prev.map((item, i) =>
        i === index ? { ...item, showMenu: !item.showMenu } : { ...item, showMenu: false }
      )
    );
  };

  const removeFile = (index: number) => {
    setSelectedFiles((prev) => prev.filter((_, i) => i !== index));
    setErrorMessage(null);
  };

  const selectSubSection = (index: number, subSection: string) => {
    const updated = [...selectedFiles];
    updated[index].selectedSubSection = subSection;
    updated[index].selectedFormat = "";
    setSelectedFiles(updated);
  };

  const selectFormat = (index: number, format: string, subSection: string) => {
    const updated = [...selectedFiles];
    updated[index].selectedFormat = `${subSection}:${format}`;
    updated[index].showMenu = false;
    setSelectedFiles(updated);
  };

  const handleConvert = async () => {
    if (isConverting) return;
    if (selectedFiles.length === 0) {
      setErrorMessage("No files selected for conversion.");
      return;
    }
    if (selectedFiles.some((item) => !item.selectedFormat)) {
      setErrorMessage("Please select a format for all files.");
      return;
    }
    if (selectedFiles.length > 5) {
      setErrorMessage("Maximum 5 files allowed.");
      return;
    }
    console.log("Starting conversion for files:", selectedFiles.map(item => ({
      name: item.file.name,
      id: item.id,
      format: item.selectedFormat,
      size: item.file.size,
      type: item.file.type,
    })));
    const formData = new FormData();
    const formats = selectedFiles.map((item) => {
      const [subSection, target] = item.selectedFormat.split(':');
      return {
        name: item.file.name,
        target: target.toLowerCase().replace(' image compress', '').replace(' document compress', '').replace(' video compress', ''),
        type: item.section,
        subSection,
        id: item.id,
      };
    });
    console.log('Formats sent to backend:', JSON.stringify(formats));
    selectedFiles.forEach((item, index) => {
      console.log(`Appending file ${index + 1}: ${item.file.name} (${item.file.size} bytes)`);
      formData.append("files", item.file);
    });
    formData.append("formats", JSON.stringify(formats));
    setIsConverting(true);
    setConvertedFiles([]);
    setErrorMessage(null);
    const timeout = 300000; // 5-minute timeout
    try {
      // Pre-flight health check
      console.log("Checking server availability at:", `${API_URL}/health`);
      const healthCheck = await fetch(`${API_URL}/health`, {
        method: "GET",
        headers: { "Origin": window.location.origin },
        signal: AbortSignal.timeout(5000),
      });
      if (!healthCheck.ok) {
        throw new Error(`Server health check failed with status ${healthCheck.status}: ${await healthCheck.text()}`);
      }
      console.log("Server health check passed:", await healthCheck.json());

      const controller = new AbortController();
      const maxRetries = 3;
      let attempts = 0;
      let res: Response | null = null;
      while (attempts < maxRetries) {
        try {
          console.log(`Conversion attempt ${attempts + 1} of ${maxRetries} to: ${API_URL}/api/convert`);
          const timeoutId = setTimeout(() => {
            controller.abort(new Error(`Conversion request timed out after ${timeout / 1000} seconds`));
          }, timeout);
          res = await fetch(`${API_URL}/api/convert`, {
            method: "POST",
            body: formData,
            headers: { "Origin": window.location.origin },
            signal: controller.signal,
          });
          clearTimeout(timeoutId);
          break;
        } catch (err) {
          attempts++;
          if (
            attempts === maxRetries ||
            (typeof err === "object" && err !== null && "name" in err && (err as any).name === 'AbortError')
          ) {
            throw err;
          }
          const errMsg = typeof err === "object" && err !== null && "message" in err ? (err as any).message : String(err);
          console.warn(`Fetch attempt ${attempts} failed: ${errMsg}. Retrying in ${2000 * attempts}ms...`);
          setErrorMessage(`Conversion attempt ${attempts} failed. Retrying in ${2 * attempts} seconds...`);
          await new Promise(resolve => setTimeout(resolve, 2000 * attempts));
        }
      }
      if (!res || !res.ok) {
        const errorData = res ? await res.text() : 'No response from server';
        throw new Error(`Conversion failed with status ${res?.status || 'unknown'}: ${errorData}`);
      }
      const data = await res.json();
      console.log("Conversion response:", data);
      const converted = await Promise.all(
        data.files.map(async (file: { name: string; path: string; id: string }) => {
          try {
            console.log(`Fetching converted file: ${file.name} from ${API_URL}${file.path} (ID: ${file.id})`);
            const maxFetchRetries = 3;
            let fetchAttempts = 0;
            while (fetchAttempts < maxFetchRetries) {
              try {
                const fileRes = await fetch(`${API_URL}${file.path}`, {
                  headers: {
                    'Accept': 'application/octet-stream',
                    'Origin': window.location.origin,
                  },
                });
                if (!fileRes.ok) {
                  const errorText = await fileRes.text();
                  throw new Error(`Failed to fetch ${file.path}: Status ${fileRes.status}, Response: ${errorText}`);
                }
                const blob = await fileRes.blob();
                const url = window.URL.createObjectURL(blob);
                return { name: file.name, url, loading: false, originalId: file.id };
              } catch (err) {
                fetchAttempts++;
                if (fetchAttempts === maxFetchRetries) {
                  console.error(`Error fetching file ${file.name} after ${maxFetchRetries} attempts:`, err);
                  return null;
                }
                await new Promise(resolve => setTimeout(resolve, 1000 * fetchAttempts));
              }
            }
          } catch (err) {
            console.error(`Error fetching file ${file.name}:`, err);
            return null;
          }
        })
      );
      const validConverted = converted.filter(file => file !== null) as ConvertedFile[];
      console.log("Converted files set:", validConverted);
      setConvertedFiles(validConverted);
      if (converted.some(file => file === null)) {
        setErrorMessage("Some files failed to convert or download. The PDF may be encrypted or corrupted. Try a different PDF.");
      } else if (validConverted.length === 0) {
        setErrorMessage("No files were converted successfully. The PDF may be encrypted or corrupted. Try a different PDF.");
      } else {
        console.log("Conversion successful, files:", validConverted);
      }
    } catch (err) {
      const msg = err instanceof Error ? err.message : "Unknown error during conversion";
      console.error("Conversion error details:", {
        message: msg,
        name: typeof err === "object" && err !== null && "name" in err ? (err as any).name : undefined,
        stack: typeof err === "object" && err !== null && "stack" in err ? (err as any).stack : undefined,
        API_URL,
        formDataFiles: selectedFiles.map(item => ({ name: item.file.name, size: item.file.size, type: item.file.type })),
        formats: JSON.stringify(formats),
      });
      setErrorMessage(
        msg.includes("timeout") ? `Conversion timed out after ${300000 / 1000} seconds. Try smaller files, simpler PDFs, or check server status.` :
        msg.includes("health check") ? "Server is not responding. Ensure the backend is running at https://convertors.onrender.com." :
        msg.includes("NetworkError") || msg.includes("Failed to fetch") ? "Network error: Unable to reach the server. Check your connection or server status." :
        msg.includes("encrypted") || msg.includes("corrupted") ? "Conversion failed: The PDF may be encrypted or corrupted. Try a different PDF." :
        `Conversion failed: ${msg}. The PDF may be encrypted or corrupted. Try a different PDF.`
      );
    } finally {
      setIsConverting(false);
    }
  };

  const handleDownload = async (url: string, name: string, index: number) => {
    setConvertedFiles(prev =>
      prev.map((file, i) => (i === index ? { ...file, loading: true } : file))
    );
    try {
      const a = document.createElement("a");
      a.href = url;
      a.download = name;
      a.click();
      console.log(`Downloaded file: ${name}`);
      await fetch(`${API_URL}/api/delete/${name}`, { method: 'DELETE' });
    } catch (err) {
      console.error(`Error downloading file ${name}:`, err);
      setErrorMessage(`Failed to download ${name}. Please try again.`);
    } finally {
      setConvertedFiles(prev =>
        prev.map((file, i) => (i === index ? { ...file, loading: false } : file))
      );
    }
  };

  return (
    <div>
      <div className="flex items-center justify-center">
        <div className="flex flex-col items-center justify-center space-y-2 converter-wrapper tall p-12 m-4 rounded-md">
          <div className="bg-red-500 text-white relative gap-4 rounded-md px-8 py-6 flex items-center space-x-6 shadow-md w-[50%] justify-center">
            <span className="font-semibold text-[15px]">Choose Files</span>
            <FaFolderOpen
              onClick={handleLocalFileClick}
              title="Upload from device"
              className="text-white text-[26px] cursor-pointer hover:scale-110 transition"
            />
            <input
              ref={fileInputRef}
              type="file"
              multiple
              onChange={handleLocalFileChange}
              style={{ display: "none" }}
              accept=".mp3,.wav,.aac,.flac,.ogg,.opus,.wma,.aiff,.m4v,.mmf,.3g2,.mp4,.avi,.mov,.webm,.mkv,.flv,.wmv,.3gp,.mpg,.ogv,.png,.jpg,.jpeg,.webp,.svg,.bmp,.gif,.ico,.tga,.tiff,.wbmp,.pdf,.doc,.docx,.txt,.rtf,.odt,.html,.ppt,.pptx,.xlsx,.zip,.7z,.epub,.mobi,.azw3,.fb2,.lit,.lrf,.pdb,.tcr"
            />
            <FaDropbox
              onClick={handleDropboxUpload}
              title="Upload from Dropbox"
              className="text-white text-[26px] cursor-pointer hover:scale-110 transition"
            />
            <FaGoogleDrive
              onClick={handleGoogleDriveUpload}
              title="Upload from Google Drive"
              className="text-white text-[26px] cursor-pointer hover:scale-110 transition"
            />
          </div>
          <div className="dropboxfoot mt-5 text-sm text-gray-400">
            50 MB maximum file size and up to 5 files. Ensure PDFs are not password-protected or encrypted.
          </div>
          {errorMessage && (
            <div className="mt-4 text-red-500 text-sm font-medium">
              {errorMessage}
            </div>
          )}
          <div className="mt-6 w-full max-w-2xl space-y-3">
            {selectedFiles.map((item, index) => {
              const convertedFile = convertedFiles.find(file => file.originalId === item.id);
              console.log(`Checking match for ${item.file.name} (ID: ${item.id}):`, convertedFile ? convertedFile.name : 'No match');
              return (
                <div
                  key={item.id}
                  className="relative bg-white text-gray-700 rounded-md px-4 py-3 shadow-md border"
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3 overflow-hidden">
                      <span className="text-xl"></span>
                      <p className="truncate max-w-[160px] text-sm font-medium">
                        {item.file.name}
                      </p>
                      <span className="text-sm text-gray-400">to</span>
                      <button
                        className="bg-gray-200 hover:bg-gray-300 text-sm rounded-md px-2 py-1"
                        onClick={() => toggleMenu(index)}
                      >
                        {item.selectedFormat.split(':')[1] || "Select format"}
                      </button>
                    </div>
                    <div className="flex items-center gap-2">
                      {convertedFile && (
                        <button
                          onClick={() =>
                            handleDownload(
                              convertedFile.url,
                              convertedFile.name,
                              convertedFiles.findIndex(file => file.originalId === item.id)
                            )
                          }
                          disabled={convertedFile.loading}
                          className="flex items-center gap-2 bg-yellow-500 text-white px-4 py-1 rounded-md text-[14px] font-semibold hover:bg-yellow-600 transition disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                          <FiDownload className="text-[16px]" />
                          {convertedFile.loading ? "Downloading..." : "Download"}
                        </button>
                      )}
                      <button
                        className="text-gray-400 hover:text-red-500 transition text-xl"
                        onClick={() => removeFile(index)}
                      >
                        
                      </button>
                    </div>
                  </div>
                  {item.showMenu && (
                    <div className="absolute top-full mt-2 right-12 bg-[#1f1f1f] text-white rounded-md p-4 w-[340px] shadow-xl text-sm font-medium z-50 flex">
                      <div className="flex flex-col border-r border-gray-700 pr-3 min-w-[100px]">
                        {Object.keys(formatOptions[item.section]).map((subSection) => (
                          <button
                            key={subSection}
                            className={`text-left px-2 py-1 rounded hover:bg-[#333] ${
                              item.selectedSubSection === subSection ? "text-white font-bold" : "text-gray-400"
                            }`}
                            onClick={() => selectSubSection(index, subSection)}
                          >
                            {subSection.charAt(0).toUpperCase() + subSection.slice(1).replace('_', ' ')}
                          </button>
                        ))}
                      </div>
                      <div className="flex-1 pl-4">
                        <div className="grid grid-cols-2 gap-2">
                          {Array.isArray(formatOptions[item.section])
                            ? null
                            : (
                              (
                                formatOptions[item.section] as Record<string, string[]>
                              )[
                                item.selectedSubSection || Object.keys(formatOptions[item.section])[0]
                              ]?.map((format) => (
                                <button
                                  key={format}
                                  className="bg-[#333] hover:bg-red-600 transition px-3 py-2 rounded text-white text-xs"
                                  onClick={() => selectFormat(index, format, item.selectedSubSection || Object.keys(formatOptions[item.section])[0])}
                                >
                                  {format}
                                </button>
                              ))
                            )
                          }
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      </div>
      <div className="flex flex-col items-center justify-center space-y-2 rounded-md">
        <h1 className="text-gray-500 text-center mt-4">
          Make sure you have uploaded valid files otherwise conversion will not be correct
        </h1>
        <button
          onClick={handleConvert}
          disabled={isConverting || selectedFiles.length === 0}
          className={`flex items-center gap-2 bg-red-400 text-white px-5 py-2 rounded-md text-[15px] font-semibold mt-2 hover:bg-red-500 transition ${isConverting || selectedFiles.length === 0 ? "opacity-50 cursor-not-allowed" : ""}`}
        >
          <FiArrowRight className="text-[16px]" />
          {isConverting ? "Converting..." : "Convert files"}
        </button>
      </div>
    </div>
  );
}
then i have .env file 
VITE_API_URL=https://convertors.onrender.com
VITE_GOOGLE_CLIENT_ID=866725812936-fvjl5btdg8d8s8mc03aihrvs3tmj3q6h.apps.googleusercontent.com
VITE_GOOGLE_API_KEY=AIzaSyDtxORXGl-d3mMhG4TKBGS90scPCX7JGyM
VITE_DROPBOX_APP_KEY=2434iawyecdjpxc